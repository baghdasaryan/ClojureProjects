#+TITLE: Fluent, Composable Error Handling
#+AUTHOR: Brian Beckman
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{tikz-cd}
#+LATEX_HEADER: \usetikzlibrary{matrix,arrows,positioning,scopes,chains}
#+LATEX_HEADER: \tikzset{node distance=2cm, auto}
#+BEGIN_COMMENT
The following line generates a benign error
#+LATEX_HEADER: \usepackage{amsmath, amsthm, amssymb}
#+END_COMMENT
#+STYLE: <link rel="stylesheet" type="text/css" href="styles/default.css" />
#+BEGIN_COMMENT
  TODO: Integrate BibTeX
#+END_COMMENT

* Introduction
  
  Consider a program composed of /serially dependent computations/,
  any of which produces either a value to feed to the next computation
  in-line, or an error. If any computation in the sequence produces an
  error, no downstream computations should be attempted and that error
  should be the result of the entire sequence.

  We show a sequence of solutions of increasing elegance in Java and
  Clojure for this program. The solutions are in fluent style, which
  minimizes the number of temporary variables that must be invented
  and named. This style directly mimics the abstract data flow of the
  solution.

  We further show techniques for fluent error handling, both with
  exceptions and with returned error codes.

* Motivating Example Problem  

  As a concrete example, suppose we must
  get an authorization token, do a database lookup, do a web-service
  call, filter the results of that call, do another web-servie call,
  and then combine the results. The data flow of our program
  resembles that in figure \ref{fig:dataflow}.

\begin{figure}
\begin{center}
\begin{tikzpicture}[
  font=\sffamily,
  every matrix/.style={ampersand replacement=\&,column sep=1cm,row sep=1cm},
  source/.style={draw,thick,rounded corners,fill=yellow!20,inner sep=.3cm},
  process/.style={draw,thick,circle,fill=blue!20},
  sink/.style={source,fill=green!20},
  rectangle/.style={draw,very thick,shape=rectangle,inner sep=.3cm},
  dots/.style={gray,scale=2},
  invisible/.style={},
  to/.style={->,>=stealth',shorten >=1pt,semithick,font=\sffamily\footnotesize},
  every node/.style={align=center}]

  % Position  nodes using a matrix layout
  \matrix{
      {}
      \& \node[source] (auth) {get authToken};
      \& \\

      {}
      \& \node[process] (database) {read\\database};
      \& \\

      \node[process] (wscall1) {call web\\svc 1};
      \& 
      \& \node[process] (wscall2) {call web\\svc 2}; \\

      \node[process] (filter) {filter};
      \&
      \& \node[invisible] (placeholder) {}; \\

      {}
      \& \node[process] (combine) {combine};
      \& \\

      {}
      \& \node[sink] (result) {result};
      \& \\
  };

  % Draw the arrows between the nodes and label them.
  \draw[to] (auth) -- node[midway,right] {auth\\token} (database);
  \draw[to] (database) -- node[midway,left] {PO} (wscall1);
  \draw[to] (database) -- node[midway,right] {PO} (wscall2);
  \draw[to] (wscall1)  -- node[midway,left] {item} (filter);
  \draw[to] (filter)   -- node[midway,left] {item} (combine);
  \draw[to] (wscall2)  -- node[midway,right] {price} (combine);
  \draw[to] (combine)  -- (result);

\end{tikzpicture}
\end{center}
\caption{\label{fig:dataflow}Serially dependent computations}
\end{figure}

** Fluent Solution in Java, No Error Handling

  In the \mbox{C++ -- like} languages, including JavaScript and Java,
  we might keep intermediate results in instance variables and model
  the flow as methods that produce instances from instances, that is,
  as \textbf{transforms}. This style is called \textbf{fluent style}
  because the text of the program resembles the flow in the diagram.
  
  Imagine a /main/ program like the following, in which transforms are
  on their own lines, indented from their /sources/ by one
  \mbox{4-space} tab stop. The \textbf{source} of a transform is an
  expression that produces an object.

#+BEGIN_SRC java :tangle no
    public static void main(String[] args) {
        Computation databaseResults = new Computation()
            .authorize()
            .readDatabase();
        String result = databaseResults
            .callWebService()
            .filterResults()
            .combineResults(databaseResults
                .callOtherWebService());
        System.out.println(result); } }
#+END_SRC

  Notice that we save the /Computation/ produced by reading the
  database in its own local variable, namely /databaseResults/. We do
  so because the dataflow branches from that result and we need to
  use it twice, once as the source for calling the first web service
  and once as the source for calling the second web service. If not
  for this branching and recombining of the dataflow, we might have
  written the entire program as one, fluent expression. 

  The following is a complete program that mocks out the database and
  web-service calls and can be compiled and executed, even online in
  some service like http://www.compileonline.com/compile_java_online.php.

#+BEGIN_SRC java :tangle no
public class Computation {
    private String authToken;
    private String databaseResults;
    private String webServiceCallResults;
    private String filteredWebServiceCallResults;
    private String otherWebServiceCallResults;
    
    public Computation () {}
    public Computation authorize() {
        authToken = "John's credentials";
        return this; }
    public Computation readDatabase() {
        databaseResults = "{\"name\":\"John\", \"PO\":\"421357\"}";
        return this; }
    public Computation callWebService() {
        webServiceCallResults =
            "{\"item\":\"camera\", \"item\":\"shoes\"}";
        return this; }
    public Computation filterResults() {
        filteredWebServiceCallResults =
            "{\"item\":\"camera\"}";
        return this; }
    public Computation callOtherWebService() {
        otherWebServiceCallResults = "{\"price\":\"420.00\"}";
        return this; }
    public String combineResults(Computation other) {
        return "{[" + filteredWebServiceCallResults +
            "," + otherWebServiceCallResults + "]}"; }

    public static void main(String[] args) {
        Computation databaseResults = new Computation()
            .authorize()
            .readDatabase();
        String result = databaseResults
            .callWebService()
            .filterResults()
            .combineResults(databaseResults
                .callOtherWebService());
        System.out.println(result); } }
#+END_SRC

** Fluent Solution in Java, with Exceptions

   The program above has /no/ error handling. One of the better ways
   techniques for error handling in fluent style is with exceptions.
   If each sub-computation is responsible for throwing its own
   exception with error details, then a single try-catch suffices to
   get error details out of the overall sequence, leaving the
   essential dataflow expression unchanged. Our main routine has
   minimal changes, and becomes simply

#+BEGIN_SRC java :tangle no
    public static void main(String[] args) {
        try {
            Computation databaseResults = new Computation()
                .authorize()
                .readDatabase();
            String result = databaseResults
                .callWebService()
                .filterResults()
                .combineResults(databaseResults
                    .callOtherWebService());
            System.out.println(result); }
        catch (Exception e) {
            System.out.println(e.getMessage());
    }   }
#+END_SRC
   noting, in passing, that resource freeing (database connections,
   sockets, file handles, etc.) is ignored here.[fn::Idiomatically,
   resource management can be handled in a /finally/ clause or with
   Java 7's automatic resource management. See http://bit.ly/15GYkMh]

   Let's give each mocked sub-computation a \mbox{10\%} chance of
   erroring, and our entire sample becomes just the following:

#+BEGIN_SRC java :tangle no
import java.util.Random;
public class Computation {
    private String authToken;
    private String databaseResults;
    private String webServiceCallResults;
    private String filteredWebServiceCallResults;
    private String otherWebServiceCallResults;
    private static Random random = new java.util.Random();
    private static Boolean randomlyError() {
        return random.nextDouble() < 0.10; }
    
    public Computation () {}
    public Computation authorize() throws Exception {
        if (randomlyError()) { throw new Exception("auth errored"); }
        authToken = "John's credentials";
        return this; }
    public Computation readDatabase() throws Exception {
        if (randomlyError()) { throw new Exception("database errored"); }
        databaseResults = "{\"name\":\"John\", \"PO\":\"421357\"}";
        return this; }
    public Computation callWebService() throws Exception {
        if (randomlyError()) { throw new Exception("ws1 errored"); }
        webServiceCallResults =
            "{\"item\":\"camera\", \"item\":\"shoes\"}";
        return this; }
    public Computation filterResults() throws Exception {
        if (randomlyError()) { throw new Exception("filter errored"); }
        filteredWebServiceCallResults =
            "{\"item\":\"camera\"}";
        return this; }
    public Computation callOtherWebService() throws Exception {
        if (randomlyError()) { throw new Exception("ws2 errored"); }
        otherWebServiceCallResults = "{\"price\":\"420.00\"}";
        return this; }
    public String combineResults(Computation other) throws Exception {
        if (randomlyError()) { throw new Exception("combine errored"); }
        return "{[" + filteredWebServiceCallResults +
            "," + otherWebServiceCallResults + "]}"; }

    public static void main(String[] args) {
        try {
            Computation databaseResults = new Computation()
                .authorize()
                .readDatabase();
            String result = databaseResults
                .callWebService()
                .filterResults()
                .combineResults(databaseResults
                    .callOtherWebService());
            System.out.println(result); }
        catch (Exception e) {
            System.out.println(e.getMessage());
}   }   }
#+END_SRC

** Fluency Lost Without Exceptions

   Error handling with exceptions is
   debatable,[fn::http://www.joelonsoftware.com/items/2003/10/13.html]
   especially in Java where runtime exceptions need not be
   declared,[fn::http://bit.ly/1e5P6Cg] but the alternative of checked
   exceptions can be considered harmful.[fn::http://bit.ly/9NyrdD]

   Rather than join the debate, just imagine that we have decided
   against exceptions for whatever reason and see if we can write
   reasonable code.

   Add a private String field, /errorResult/, and let every method set
   the error result if and only if it errors. We must change
   /combineResults/; it can no longer return just a /String/, but
   rather a /Computation/, because it may, itself, produce an error.
   Furthermore, we lose the fluent style because every call must be
   individually checked.

   A particularly nasty way to do this is as follows:

#+BEGIN_SRC java :tangle no
    public static String computation () {
        Computation c1 = new Computation();
        Computation c2 = c1.authorize();
        if (c2.errorResult.isEmpty()) {
            Computation c3 = c2.readDatabase();
            if (c3.errorResult.isEmpty()) {
                Computation c4 = c3.callWebService();
                if (c4.errorResult.isEmpty()) {
                    Computation c5 = c4.filterResults();
                    if (c5.errorResult.isEmpty()) {
                        Computation c6 = c3.callOtherWebService();
                        if (c6.errorResult.isEmpty()) {
                            Computation c7 = c5.combineResults(c6);
                            if (c7.errorResult.isEmpty()) {
                                return c7.getResult(); }
                            else {return c7.errorResult;} }
                        else {return c6.errorResult;} }
                    else {return c5.errorResult;} }
                else {return c4.errorResult;} }
            else {return c3.errorResult;} }
        else {return c2.errorResult;} }
    public static void main(String[] args) {
        System.out.println(computation()); }
#+END_SRC

   This is so intolerable as to barely deserve criticism, despite the
   fact that its working set is optimized for the positive
   path![fn::The error branches are all at addresses far from the
   non-error branches, which are clustered together for  maximum locality.] We've
   lost any correspondence between the program text and the program
   specification, and all options for nesting and placement of curly
   braces are ludicrous.
   
   The prevailing style, nowadays, is to reverse all the branches and
   to return as early as possible from the main routine. Despite the
   fact that multiple returns were condemned in the
   dogma of structured programming and are lethal in code that
   manages resources,[fn::http://bit.ly/sAvDmY] the
   justification for this is two-fold:
   + it results in linear code that can be read from top to bottom
   + modern compilers can reverse the branches in the generated code
     automatically after a post-compilation profiling
     step[fn::http://en.wikipedia.org/wiki/Profile-guided_optimization]

   This alternative[fn::favored in the previously cited
   Joel-on-Software blog] is the following:

#+BEGIN_SRC java :tangle no
    public static String computation() {
        Computation c1 = new Computation();
        Computation c2 = c1.authorize();
        if (! c2.errorResult.isEmpty()) {return c2.errorResult;}
        Computation c3 = c2.readDatabase();
        if (! c3.errorResult.isEmpty()) {return c3.errorResult;}
        Computation c4 = c3.callWebService();
        if (! c4.errorResult.isEmpty()) {return c4.errorResult;}
        Computation c5 = c4.filterResults();
        if (! c5.errorResult.isEmpty()) {return c5.errorResult;}
        Computation c6 = c3.callOtherWebService();
        if (! c6.errorResult.isEmpty()) {return c6.errorResult;}
        Computation c7 = c5.combineResults(c6);
        if (! c7.errorResult.isEmpty()) {return c7.errorResult;}
        return c7.getResult(); }
    public static void main(String[] args) {
        System.out.println(computation()); }
#+END_SRC

This, at least, gets rid of the ludicrous nesting, but exposes another
deep weakness: we have a proliferation of temporary variables just to
hold the /Computations/ returned by the intermediate stages. Why
bother with this when we have no hope of fluent style? Let's go to

#+BEGIN_SRC java :tangle no
    public static String computation() {
        Computation c1 = new Computation();
        c1.authorize();
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        c1.readDatabase();
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        c1.callWebService();
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        c1.filterResults();
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        c1.callOtherWebService();
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        c1.combineResults(c1);
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        return c1.getResult(); }
    public static void main(String[] args) {
        System.out.println(computation()); }
#+END_SRC

The whole program, now, is the following

#+BEGIN_SRC java :tangle no
import java.util.Random;
public class Computation {
    private String errorResult;
    private String result;
    private String authToken;
    private String databaseResults;
    private String webServiceCallResults;
    private String filteredWebServiceCallResults;
    private String otherWebServiceCallResults;
    private static Random random = new java.util.Random();
    private static Boolean randomlyError() {
        return random.nextDouble() < 0.10; }
    
    public Computation () {errorResult=""; result="no result";}
    public Computation authorize() {
        if (randomlyError()) { errorResult = "auth errored"; }
        authToken = "John's credentials";
        return this; }
    public Computation readDatabase() {
        if (randomlyError()) { errorResult = "database errored"; }
        databaseResults = "{\"name\":\"John\", \"PO\":\"421357\"}";
        return this; }
    public Computation callWebService() {
        if (randomlyError()) { errorResult = "ws1 errored"; }
        webServiceCallResults =
            "{\"item\":\"camera\", \"item\":\"shoes\"}";
        return this; }
    public Computation filterResults() {
        if (randomlyError()) { errorResult = "filter errored"; }
        filteredWebServiceCallResults =
            "{\"item\":\"camera\"}";
        return this; }
    public Computation callOtherWebService() {
        if (randomlyError()) { errorResult = "ws2 errored"; }
        otherWebServiceCallResults = "{\"price\":\"420.00\"}";
        return this; }
    public Computation combineResults(Computation other) {
        if (randomlyError()) { errorResult = "combine errored"; }
        result = "{[" + filteredWebServiceCallResults +
            "," + otherWebServiceCallResults + "]}"; 
        return this;}
    public String getResult() {return result;}
    public static String computation() {
        Computation c1 = new Computation();
        c1.authorize();
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        c1.readDatabase();
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        c1.callWebService();
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        c1.filterResults();
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        c1.callOtherWebService();
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        c1.combineResults(c1);
        if (! c1.errorResult.isEmpty()) {return c1.errorResult;}
        return c1.getResult(); }
    public static void main(String[] args) {
        System.out.println(computation());
}   }
#+END_SRC

, and  that we do not want to throw Exceptions, but
   rather return error codes.

  So packaged, we may write the program
  directly as a sequence /via/ Clojure's \verb|->| or \verb|->>| or
  the \verb|let| syntax, as follows:

#+BEGIN_SRC clojure :tangle no
  (try
    (let [auth-token        (get-auth-token)
          db-results        (read-database auth-token)
          svc-results       (call-web-service db-results)
          other-svc-results (call-other-web-service svc-results)
          filtered-results  (filter my-predicate 
        read-database
        
    (catch Exception e (.getMessage e)))

#+END_SRC

  The desired behavior is similar to that of the Maybe
  monad,[fn::http://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Maybe_monad]
  the difference being that /Maybe/ just produce /Nothing/ if anything
  goes wrong. The consumer of the computation doesn't know what stage
  of the pipeline failed nor any details at all about the error.
  /Maybe/ suppresses all that. Such a situation is not tolerable in
  the real world. Consider the example of a database retrieval
  followed by a few web-service calls followed by a filter and
  transformation followed by a logging call followed by output to UI
  components. If something goes wrong in this sequence of
  computations, we need to know exactly where and as much detail as
  we can get about the failure. But we certainly don't want any
  computations downstream of the failure to be attempted.


* Code

#+BEGIN_SRC text :exports none :mkdirp yes :tangle ./ex1/.gitignore
/target
/lib
/classes
/checkouts
pom.xml
pom.xml.asc
*.jar
*.class
.lein-deps-sum
.lein-failures
.lein-plugins
.lein-repl-history
#+END_SRC

#+BEGIN_SRC markdown :exports none :mkdirp yes :tangle ./ex1/README.md
# ex1
A Clojure library designed to do SOMETHING. 
## Usage
TODO
## License
Copyright © 2013 TODO
#+END_SRC

#+BEGIN_SRC clojure :noweb yes :mkdirp yes :tangle ./ex1/project.clj :exports none
  <<project-file>>
#+END_SRC

#+NAME: project-file
#+BEGIN_SRC clojure :tangle no
(defproject ex1 "0.1.0-SNAPSHOT"
  :description "Project Fortune's Excel Processor"
  :url "http://example.com/TODO"
  :license {:name "TODO"
            :url "TODO"}
  :dependencies [[org.clojure/clojure     "1.5.1"]
                 [org.clojure/algo.monads "0.1.4"]
                 [org.clojure/data.zip    "0.1.1"]
                 [dk.ative/docjure        "1.6.0"]
                ]
  :repl-options {:init-ns ex1.core})
#+END_SRC

#+BEGIN_SRC markdown :exports none :mkdirp yes :tangle ./ex1/doc/intro.md
# Introduction to ex1
TODO: The project documentation is the .org file that produced 
this output, but it still pays to read
http://jacobian.org/writing/great-documentation/what-to-write/
#+END_SRC

#+name: top-level-load-block
#+BEGIN_SRC clojure :exports none :mkdirp yes :tangle ./ex1/src/ex1/core.clj :padline no :results silent :noweb yes
<<main-namespace>>
<<main-monad>>
#+END_SRC

#+name: main-namespace
#+BEGIN_SRC clojure :results silent 
(ns ex1.core
  (:use clojure.algo.monads))
#+END_SRC

#+name: main-monad
#+BEGIN_SRC clojure :results silent 
(defmonad if-not-error-m
  [m-result (fn [value] value)
   m-bind   (fn [value f]
              (if-not (:error value)
                (f value) 
                value))
   m-zero   {:error "unspecified error"}
   m-plus   (fn [& mvs]
              (first (drop-while :error mvs)))
   
   ])
#+END_SRC

#+BEGIN_SRC clojure  :exports none :mkdirp yes :tangle ./ex1/test/ex1/core_test.clj :padline no :results silent :noweb yes
<<main-test-namespace>>
<<test-monads>>
#+END_SRC

#+name: main-test-namespace
#+BEGIN_SRC clojure :results silent 
(ns ex1.core-test
  (:require [clojure.test        :refer :all]
            [ex1.core            :refer :all]
            [clojure.algo.monads :refer :all]))
#+END_SRC

#+name: test-monads
#+BEGIN_SRC clojure :results silent 
(deftest exception-throwing-test
  (testing "exceptions are thrown"
    (is (thrown? ArithmeticException (/ 1 0)))
    (is (thrown-with-msg? ArithmeticException #"Divide by zero" (/ 1 0)))
    ))

(deftest comprehension-test
  (testing "sequence monad and comprehension"
    (is (= (domonad sequence-m
                    [a (range 5)
                     b (range a)]
                    (* a b))
           (for [a (range 5)
                 b (range a)]
             (* a b)))
        "Monadic sequence equals for comprehension")))

(defn- divisible? [n k]
  (= 0 (rem n k)))

(def ^:private not-divisible?
  (complement divisible?))

(defn- divide-out [n k]
  (if (divisible? n k)
    (recur (quot n k) k)
    n))

(defn- error-returning-check-divisibility-by [k n]
  (let [q (divide-out n k)]
    (if (= q n)
      {:error (str n ": not divisible by " k)}
      q)))

(defn- exception-throwing-check-divisibility-by [k n]
  (let [q (divide-out n k)]
    (if (= q n)
      (throw (Exception.
              (str {:error (str n ": not divisible by " k)})))
      q)))

(defn- best-small-divisor-sample [a2]
  (try
    (->> a2
        (exception-throwing-check-divisibility-by 2)
        (exception-throwing-check-divisibility-by 3)
        (exception-throwing-check-divisibility-by 5)
        (exception-throwing-check-divisibility-by 7))
    (catch Exception e (.getMessage e)))
  )

()

(defn- ugly-small-divisor-sample [a2]
  (if (not-divisible? a2 2)
    {:error (str a2 ": not divisible by 2")}
    (let [a3 (quot a2 2)]
      (if (not-divisible? a3 3)
        {:error (str a3 ": not divisible by 3")}
        (let [a5 (quot a3 3)]
          (if (not-divisible? a5 5)
            {:error (str a5 ": not divisible by 5")}
            (let [a7 (quot a5 5)]
              (if (not-divisible? a7 7)
                {:error (str a7 ": not divisible by 7")}
                {:success (str a7 ": divisible by 2, 3, 5, and 7")}
                )
              )
            )
          )
        )
      )
    )
  )

(defn- not-pretty-enough-small-divisor-sample [a2]
  (with-monad if-not-error-m
    (->
     (m-bind (m-result a2 ) (fn [a2]  (m-result (error-returning-check-divisibility-by 2 a2))))
     (m-bind  (fn [a3]  (m-result (error-returning-check-divisibility-by 3 a3))))
     (m-bind  (fn [a5]  (m-result (error-returning-check-divisibility-by 5 a5))))
     (m-bind  (fn [a7]  (m-result (error-returning-check-divisibility-by 7 a7))))
     )))

(defn- prettier-small-divisor-sample [a2]
  (domonad if-not-error-m
           [a3  (error-returning-check-divisibility-by 2 a2)
            a5  (error-returning-check-divisibility-by 3 a3)
            a7  (error-returning-check-divisibility-by 5 a5)
            a11 (error-returning-check-divisibility-by 7 a7)
            ]
           a11))

(defn- even-prettier-small-divisor-sample [a2]
  (with-monad if-not-error-m
    ((m-chain
      [(partial error-returning-check-divisibility-by 2)
       (partial error-returning-check-divisibility-by 3)
       (partial error-returning-check-divisibility-by 5)
       (partial error-returning-check-divisibility-by 7)
       ])
     a2)))

(defn- prettiest-small-divisor-sample [a2]
  (with-monad if-not-error-m
    ((m-chain
      (vec (map #(partial error-returning-check-divisibility-by %)
                [2 3 5 7])))
     a2)))

(deftest if-not-error-monad-test
  (testing "the if-not-error-monad"
    (is (=
         (ugly-small-divisor-sample 42)
         (prettier-small-divisor-sample 42)))
    (is (=
         (ugly-small-divisor-sample 42)
         (not-pretty-enough-small-divisor-sample 42)))
    (is (=
         (ugly-small-divisor-sample 42)
         (even-prettier-small-divisor-sample 42)))
    (is (=
         (ugly-small-divisor-sample 42)
         (prettiest-small-divisor-sample 42)))    )
)
#+END_SRC
 
* References

* Conclusion

  
