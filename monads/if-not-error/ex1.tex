% Created 2013-09-08 Sun 07:52
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage[normalem]{ulem}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{hyperref}
\tolerance=1000
\usepackage{tikz}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{matrix,arrows,positioning,scopes,chains}
\tikzset{node distance=2cm, auto}
\author{Brian Beckman}
\date{\today}
\title{Fluent, Composable Error Handling}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.0.7)}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction}
\label{sec-1}

Consider a program composed of \emph{serially dependent computations},
any of which produces either a value to feed to the next computation
in line or an error. If any computation in the sequence produces an
error, no downstream computations should be attempted and that error
should be the result of the entire sequence.

We show how to write such a program in fluent style, which
minimizes the number of temporary variables that must be invented
and named. This style directly mimics the abstract data flow of the
solution. We further show techniques for fluent error handling,
both with exceptions and with returned error codes.
\section{Motivating Example Problem}
\label{sec-2}

As a concrete example, suppose we must
get an authorization token, do a database lookup, do a web-service
call, filter the results of that call, do another web-servie call,
and then combine the results. The data flow of our program
resembles that in figure \ref{fig:dataflow}.

\begin{figure}
\begin{center}
\begin{tikzpicture}[
  font=\sffamily,
  every matrix/.style={ampersand replacement=\&,column sep=1cm,row sep=1cm},
  source/.style={draw,thick,rounded corners,fill=yellow!20,inner sep=.3cm},
  process/.style={draw,thick,circle,fill=blue!20},
  sink/.style={source,fill=green!20},
  rectangle/.style={draw,very thick,shape=rectangle,inner sep=.3cm},
  dots/.style={gray,scale=2},
  invisible/.style={},
  to/.style={->,>=stealth',shorten >=1pt,semithick,font=\sffamily\footnotesize},
  every node/.style={align=center}]

  % Position  nodes using a matrix layout
  \matrix{
      {}
      \& \node[source] (auth) {get authToken};
      \& \\

      {}
      \& \node[process] (database) {read\\database};
      \& \\

      \node[process] (wscall1) {call web\\svc 1};
      \& 
      \& \node[process] (wscall2) {call web\\svc 2}; \\

      \node[process] (filter) {filter};
      \&
      \& \node[invisible] (placeholder) {}; \\

      {}
      \& \node[process] (combine) {combine};
      \& \\

      {}
      \& \node[sink] (result) {result};
      \& \\
  };

  % Draw the arrows between the nodes and label them.
  \draw[to] (auth) -- node[midway,right] {auth\\token} (database);
  \draw[to] (database) -- node[midway,left] {PO} (wscall1);
  \draw[to] (database) -- node[midway,right] {PO} (wscall2);
  \draw[to] (wscall1)  -- node[midway,left] {item} (filter);
  \draw[to] (filter)   -- node[midway,left] {item} (combine);
  \draw[to] (wscall2)  -- node[midway,right] {price} (combine);
  \draw[to] (combine)  -- (result);

\end{tikzpicture}
\end{center}
\caption{\label{fig:dataflow}Serially dependent computations}
\end{figure}

In the \mbox{C++ -- like} languages, including JavaScript and Java,
we might keep intermediate results in instance variables and model
the flow as methods that produce instances from instances, that is,
as \textbf{transforms}, also called \textbf{fluent style}. Imagine a
\emph{main} program like the following, in which put transforms on their
own lines, indented from their \emph{sources} by one \mbox{4-space} tab
stop. The \textbf{source} of a transform is an expression that
produces an object.

\begin{verbatim}
public static void main(String[] args) {
    Computation databaseResults = new Computation()
        .authorize()
        .readDatabase();
    String result = databaseResults
        .callWebService()
        .filterResults()
        .combineResults(databaseResults
            .callOtherWebService());
    System.out.println(result); } }
\end{verbatim}

Notice that we save the \emph{Computation} produced by reading the
database in its own local variable, namely \emph{databaseResults}. We do
so because the dataflow branches from that result and we need to
use it twice, once as the source for calling the first web service
and once as the source for calling the second web service. If not
for this branching and recombining of the dataflow, we might have
written the entire program as one, fluent expression. 

\begin{verbatim}
public class Computation {
    private String authToken;
    private String databaseResults;
    private String webServiceCallResults;
    private String filteredWebServiceCallResults;
    private String otherWebServiceCallResults;

    public Computation () {}
    public Computation authorize() {
        authToken = "John's credentials";
        return this; }
    public Computation readDatabase() {
        databaseResults = "{\"name\":\"John\", \"PO\":\"421357\"}";
        return this; }
    public Computation callWebService() {
        webServiceCallResults =
            "{\"item\":\"camera\", \"item\":\"shoes\"}";
        return this; }
    public Computation filterResults() {
        filteredWebServiceCallResults =
            "{\"item\":\"camera\"}";
        return this; }
    public Computation callOtherWebService() {
        otherWebServiceCallResults = "{\"price\":\"420.00\"}";
        return this; }
    public String combineResults(Computation other) {
        return "{[" + filteredWebServiceCallResults +
            "," + otherWebServiceCallResults + "]}"; }

    public static void main(String[] args) {
        Computation databaseResults = new Computation()
            .authorize()
            .readDatabase();
        String result = databaseResults
            .callWebService()
            .filterResults()
            .combineResults(databaseResults
                .callOtherWebService());
        System.out.println(result); } }
\end{verbatim}

One of the better ways to write such a program is to package every
computation in a function (or method) that either produces a correct
value or throws an exception.

So packaged, we may write the program
directly as a sequence \emph{via} Clojure's \verb|->| or \verb|->>| or
the \verb|let| syntax, as follows:

\begin{verbatim}
(try
  (let [auth-token        (get-auth-token)
        db-results        (read-database auth-token)
        svc-results       (call-web-service db-results)
        other-svc-results (call-other-web-service svc-results)
        filtered-results  (filter my-predicate 
      read-database

  (catch Exception e (.getMessage e)))
\end{verbatim}

The desired behavior is similar to that of the Maybe
monad,\footnote{\url{http://en.wikipedia.org/wiki/Monad_(functional_programming)}\#The$_{\text{Maybe}}$$_{\text{monad}}$}
the difference being that \emph{Maybe} just produce \emph{Nothing} if anything
goes wrong. The consumer of the computation doesn't know what stage
of the pipeline failed nor any details at all about the error.
\emph{Maybe} suppresses all that. Such a situation is not tolerable in
the real world. Consider the example of a database retrieval
followed by a few web-service calls followed by a filter and
transformation followed by a logging call followed by output to UI
components. If something goes wrong in this sequence of
computations, we need to know exactly where and as much detail as
we can get about the failure. But we certainly don't want any
computations downstream of the failure to be attempted.

\section{Code}
\label{sec-3}

\begin{figure}[H]
\label{project-file}
\begin{verbatim}
(defproject ex1 "0.1.0-SNAPSHOT"
  :description "Project Fortune's Excel Processor"
  :url "http://example.com/TODO"
  :license {:name "TODO"
            :url "TODO"}
  :dependencies [[org.clojure/clojure     "1.5.1"]
                 [org.clojure/algo.monads "0.1.4"]
                 [org.clojure/data.zip    "0.1.1"]
                 [dk.ative/docjure        "1.6.0"]
                ]
  :repl-options {:init-ns ex1.core})
\end{verbatim}
\end{figure}

\begin{figure}[H]
\label{main-namespace}
\begin{verbatim}
(ns ex1.core
  (:use clojure.algo.monads))
\end{verbatim}
\end{figure}

\begin{figure}[H]
\label{main-monad}
\begin{verbatim}
(defmonad if-not-error-m
  [m-result (fn [value] value)
   m-bind   (fn [value f]
              (if-not (:error value)
                (f value) 
                value))
   m-zero   {:error "unspecified error"}
   m-plus   (fn [& mvs]
              (first (drop-while :error mvs)))

   ])
\end{verbatim}
\end{figure}

\begin{figure}[H]
\label{main-test-namespace}
\begin{verbatim}
(ns ex1.core-test
  (:require [clojure.test        :refer :all]
            [ex1.core            :refer :all]
            [clojure.algo.monads :refer :all]))
\end{verbatim}
\end{figure}

\begin{figure}[H]
\label{test-monads}
\begin{verbatim}
(deftest exception-throwing-test
  (testing "exceptions are thrown"
    (is (thrown? ArithmeticException (/ 1 0)))
    (is (thrown-with-msg? ArithmeticException #"Divide by zero" (/ 1 0)))
    ))

(deftest comprehension-test
  (testing "sequence monad and comprehension"
    (is (= (domonad sequence-m
                    [a (range 5)
                     b (range a)]
                    (* a b))
           (for [a (range 5)
                 b (range a)]
             (* a b)))
        "Monadic sequence equals for comprehension")))

(defn- divisible? [n k]
  (= 0 (rem n k)))

(def ^:private not-divisible?
  (complement divisible?))

(defn- divide-out [n k]
  (if (divisible? n k)
    (recur (quot n k) k)
    n))

(defn- error-returning-check-divisibility-by [k n]
  (let [q (divide-out n k)]
    (if (= q n)
      {:error (str n ": not divisible by " k)}
      q)))

(defn- exception-throwing-check-divisibility-by [k n]
  (let [q (divide-out n k)]
    (if (= q n)
      (throw (Exception.
              (str {:error (str n ": not divisible by " k)})))
      q)))

(defn- best-small-divisor-sample [a2]
  (try
    (->> a2
        (exception-throwing-check-divisibility-by 2)
        (exception-throwing-check-divisibility-by 3)
        (exception-throwing-check-divisibility-by 5)
        (exception-throwing-check-divisibility-by 7))
    (catch Exception e (.getMessage e)))
  )

()

(defn- ugly-small-divisor-sample [a2]
  (if (not-divisible? a2 2)
    {:error (str a2 ": not divisible by 2")}
    (let [a3 (quot a2 2)]
      (if (not-divisible? a3 3)
        {:error (str a3 ": not divisible by 3")}
        (let [a5 (quot a3 3)]
          (if (not-divisible? a5 5)
            {:error (str a5 ": not divisible by 5")}
            (let [a7 (quot a5 5)]
              (if (not-divisible? a7 7)
                {:error (str a7 ": not divisible by 7")}
                {:success (str a7 ": divisible by 2, 3, 5, and 7")}
                )
              )
            )
          )
        )
      )
    )
  )

(defn- not-pretty-enough-small-divisor-sample [a2]
  (with-monad if-not-error-m
    (->
     (m-bind (m-result a2 ) (fn [a2]  (m-result (error-returning-check-divisibility-by 2 a2))))
     (m-bind  (fn [a3]  (m-result (error-returning-check-divisibility-by 3 a3))))
     (m-bind  (fn [a5]  (m-result (error-returning-check-divisibility-by 5 a5))))
     (m-bind  (fn [a7]  (m-result (error-returning-check-divisibility-by 7 a7))))
     )))

(defn- prettier-small-divisor-sample [a2]
  (domonad if-not-error-m
           [a3  (error-returning-check-divisibility-by 2 a2)
            a5  (error-returning-check-divisibility-by 3 a3)
            a7  (error-returning-check-divisibility-by 5 a5)
            a11 (error-returning-check-divisibility-by 7 a7)
            ]
           a11))

(defn- even-prettier-small-divisor-sample [a2]
  (with-monad if-not-error-m
    ((m-chain
      [(partial error-returning-check-divisibility-by 2)
       (partial error-returning-check-divisibility-by 3)
       (partial error-returning-check-divisibility-by 5)
       (partial error-returning-check-divisibility-by 7)
       ])
     a2)))

(defn- prettiest-small-divisor-sample [a2]
  (with-monad if-not-error-m
    ((m-chain
      (vec (map #(partial error-returning-check-divisibility-by %)
                [2 3 5 7])))
     a2)))

(deftest if-not-error-monad-test
  (testing "the if-not-error-monad"
    (is (=
         (ugly-small-divisor-sample 42)
         (prettier-small-divisor-sample 42)))
    (is (=
         (ugly-small-divisor-sample 42)
         (not-pretty-enough-small-divisor-sample 42)))
    (is (=
         (ugly-small-divisor-sample 42)
         (even-prettier-small-divisor-sample 42)))
    (is (=
         (ugly-small-divisor-sample 42)
         (prettiest-small-divisor-sample 42)))    )
)
\end{verbatim}
\end{figure}
\section{References}
\label{sec-4}

\section{Conclusion}
\label{sec-5}
% Emacs 24.3.1 (Org mode 8.0.7)
\end{document}
